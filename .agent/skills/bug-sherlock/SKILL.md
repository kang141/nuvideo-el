# Bug Sherlock Diagnostic Skill

---

name: bug-sherlock  
description: 以“证据链”驱动的异常诊断：快速建立事件时间线、缩小范围、定位根因，并给出可落地的修复与回归防护方案（像资深 SRE + Staff 工程师那样排查）。

---

## 触发规则

满足任一条件自动启用：

- 报错：异常堆栈 / 500 / 崩溃 / 白屏 / 卡死 / 超时 / 数据错乱
- 线上问题：偶现、难复现、只在某些环境出现、回滚后恢复
- 用户描述含糊但有症状：变慢、间歇性失败、重复请求、顺序不对
- 涉及并发/异步：race、死锁、消息队列、缓存一致性、重试风暴
- “这段代码为什么会这样”：逻辑看似正确但结果不对

不触发 / 降级：

- 用户只要“解释错误含义”，不需要深入定位
- 明确是静态语法问题（直接指出即可）

---

## 诊断流程（证据链）

1. **证据搜集（输入越准越快）**
   - 错误堆栈、终端日志、浏览器控制台、网络请求（status + payload）
   - 发生时间、频率、环境（dev/stage/prod）、是否可回滚复现
   - 相关配置/开关/版本号（尤其是最近改过的）

2. **建立时间线（Timeline First）**
   - 把“报错前发生了什么”串起来：请求 → 状态变化 → 调用链 → 外部依赖
   - 明确“最后一次正常行为”与“第一次异常行为”的分界点

3. **范围收敛（排除法）**
   - 先分层：客户端 / 网关 / 服务端 / 数据库 / 缓存 / 第三方
   - 再分类型：输入问题 / 状态问题 / 资源问题 / 时序问题 / 依赖问题

4. **变更回溯（Change Radar）**
   - 关注近期提交/发布：谁动了什么、是否触及关键链路
   - 输出“最可疑变更清单”（少而准），而不是遍历所有 commit

5. **隔离验证（最小复现）**
   - 给出最小可复现步骤或代码片段（MRE）
   - 建议加入最少量的观测点（log/metric/assert）来验证假设

6. **修复策略（短期止血 + 长期治本）**
   - **治标**：快速降低影响（降级/熔断/回滚/兜底/限流）
   - **治本**：修根因（边界校验、状态机重构、幂等、顺序保证、超时与重试策略）

7. **回归预防**
   - 建议补一个“能抓住这类 bug”的测试或守卫（而不是堆测试）
   - 加一条监控/告警，让同类问题下次“自动暴露”

---

## 职责

1. **日志深度解析**
   - 关注报错前的状态序列：输入、关键变量、外部调用结果、重试次数、耗时分布
   - 识别“看似无关但关键”的信号：warning、fallback、timeout、retry

2. **时序/并发问题捕获**
   - 针对 race、死锁、重复提交、乱序消费做“事件顺序推演”
   - 特别关注：多实例、缓存、队列、重试、幂等、事务边界

3. **定位根因而非表象**
   - 把“症状”拆成可验证的假设
   - 每一步都明确：证据是什么、排除了什么、还剩什么

4. **修复与防护**
   - 修复不仅让它“不报错”，还要让它“更不容易再错”
   - 输出可执行的防护建议：guard、assert、fallback、timeout、circuit breaker 等

---

## 输出格式（简洁但可执行）

### 1) 现象复述

- 症状：...
- 环境/频率：...
- 影响范围：...

### 2) 证据链与时间线

- T0：...
- T1：...
- T2：...
- 当前最关键证据：...

### 3) 可疑点（按优先级）

1. ...
2. ...
3. ...

### 4) 验证方案（最小成本）

- 要加的观测点：...
- 最小复现步骤：...
- 预期结果：如果是 A 会看到...；如果不是 A 会看到...

### 5) 修复建议

- 治标：...
- 治本：...

### 6) 回归预防

- 测试/守卫：...
- 监控/告警：...

---

## 执行准则

- **事实为本**：所有结论都要能指回日志/堆栈/代码路径。
- **先收敛再深挖**：先把范围缩小到 1–2 个模块，再做深入推演。
- **少猜测，多验证**：每个假设都给出一个最小验证动作。
- **优先控制影响**：线上问题先止血，再治本。
- **避免二次伤害**：修复要考虑回滚、兼容、数据一致性与性能边界。

---
